// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.27.0
// source: votes.sql

package db

import (
	"context"
	"time"
)

const createVote = `-- name: CreateVote :exec
INSERT INTO WG_Votes (SurveyId, UserId, Token, MessageId, Status, VotedAt) VALUES (?,?,?,?,?,?)
`

type CreateVoteParams struct {
	Surveyid  string    `json:"surveyid"`
	Userid    string    `json:"userid"`
	Token     string    `json:"token"`
	Messageid string    `json:"messageid"`
	Status    int8      `json:"status"`
	Votedat   time.Time `json:"votedat"`
}

func (q *Queries) CreateVote(ctx context.Context, arg CreateVoteParams) error {
	_, err := q.db.ExecContext(ctx, createVote,
		arg.Surveyid,
		arg.Userid,
		arg.Token,
		arg.Messageid,
		arg.Status,
		arg.Votedat,
	)
	return err
}

const createVoteEntry = `-- name: CreateVoteEntry :exec
INSERT INTO WG_VoteEntries (SurveyId, UserId, StatId, Value) VALUES (?,?,?,?)
`

type CreateVoteEntryParams struct {
	Surveyid string  `json:"surveyid"`
	Userid   string  `json:"userid"`
	Statid   string  `json:"statid"`
	Value    float64 `json:"value"`
}

func (q *Queries) CreateVoteEntry(ctx context.Context, arg CreateVoteEntryParams) error {
	_, err := q.db.ExecContext(ctx, createVoteEntry,
		arg.Surveyid,
		arg.Userid,
		arg.Statid,
		arg.Value,
	)
	return err
}

const deleteVote = `-- name: DeleteVote :exec
DELETE FROM WG_Votes WHERE SurveyId = ? AND UserId = ?
`

type DeleteVoteParams struct {
	Surveyid string `json:"surveyid"`
	Userid   string `json:"userid"`
}

func (q *Queries) DeleteVote(ctx context.Context, arg DeleteVoteParams) error {
	_, err := q.db.ExecContext(ctx, deleteVote, arg.Surveyid, arg.Userid)
	return err
}

const findResult = `-- name: FindResult :many
SELECT StatId, CAST(AVG(Value) AS DECIMAL(10,4)) AS AverageValue, COUNT(*) AS TotalVotes
FROM WG_VoteEntries
INNER JOIN WG_Votes ON WG_Votes.UserId = WG_VoteEntries.UserId AND WG_VoteEntries.SurveyId = WG_VoteEntries.SurveyId
WHERE WG_VoteEntries.SurveyId = ? AND WG_Votes.SurveyId = ? AND WG_Votes.Status = ?
GROUP BY StatId
`

type FindResultParams struct {
	Surveyid   string `json:"surveyid"`
	Surveyid_2 string `json:"surveyid_2"`
	Status     int8   `json:"status"`
}

type FindResultRow struct {
	Statid       string  `json:"statid"`
	Averagevalue float64 `json:"averagevalue"`
	Totalvotes   int64   `json:"totalvotes"`
}

func (q *Queries) FindResult(ctx context.Context, arg FindResultParams) ([]FindResultRow, error) {
	rows, err := q.db.QueryContext(ctx, findResult, arg.Surveyid, arg.Surveyid_2, arg.Status)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []FindResultRow
	for rows.Next() {
		var i FindResultRow
		if err := rows.Scan(&i.Statid, &i.Averagevalue, &i.Totalvotes); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const findVote = `-- name: FindVote :many
SELECT
WG_Surveys.Id AS SurveyId,
WG_Surveys.ChannelID AS SurveyChannel,
WG_Surveys.AnnouncementMessageID,
WG_Surveys.ItemName,
WG_Surveys.OpenedAt,
WG_Surveys.Deadline,
WG_Surveys.Status AS SurveyStatus,
WG_Votes.Status as VoteStatus,
WG_Votes.Token as Token,
WG_Votes.MessageId AS VoteMessage,
WG_Votes.UserId,
WG_Votes.VotedAt
FROM WG_Votes
INNER JOIN WG_Surveys ON WG_Surveys.Id = WG_Votes.SurveyId
WHERE (? = 0 OR WG_Votes.Status = ?) 
AND (? = "" OR WG_Votes.SurveyId LIKE ?)
AND (? = "" OR WG_Votes.UserId LIKE ?)
AND (? = "" OR WG_Votes.Token LIKE ?)
LIMIT ? OFFSET ?
`

type FindVoteParams struct {
	Status    int8        `json:"status"`
	Surveyid  interface{} `json:"surveyid"`
	Surveyopt string      `json:"surveyopt"`
	Userid    interface{} `json:"userid"`
	Idopt     string      `json:"idopt"`
	Token     interface{} `json:"token"`
	Tokenopt  string      `json:"tokenopt"`
	Limit     int32       `json:"limit"`
	Offset    int32       `json:"offset"`
}

type FindVoteRow struct {
	Surveyid              string    `json:"surveyid"`
	Surveychannel         string    `json:"surveychannel"`
	Announcementmessageid string    `json:"announcementmessageid"`
	Itemname              string    `json:"itemname"`
	Openedat              time.Time `json:"openedat"`
	Deadline              time.Time `json:"deadline"`
	Surveystatus          int8      `json:"surveystatus"`
	Votestatus            int8      `json:"votestatus"`
	Token                 string    `json:"token"`
	Votemessage           string    `json:"votemessage"`
	Userid                string    `json:"userid"`
	Votedat               time.Time `json:"votedat"`
}

func (q *Queries) FindVote(ctx context.Context, arg FindVoteParams) ([]FindVoteRow, error) {
	rows, err := q.db.QueryContext(ctx, findVote,
		arg.Status,
		arg.Status,
		arg.Surveyid,
		arg.Surveyopt,
		arg.Userid,
		arg.Idopt,
		arg.Token,
		arg.Tokenopt,
		arg.Limit,
		arg.Offset,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []FindVoteRow
	for rows.Next() {
		var i FindVoteRow
		if err := rows.Scan(
			&i.Surveyid,
			&i.Surveychannel,
			&i.Announcementmessageid,
			&i.Itemname,
			&i.Openedat,
			&i.Deadline,
			&i.Surveystatus,
			&i.Votestatus,
			&i.Token,
			&i.Votemessage,
			&i.Userid,
			&i.Votedat,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const findVoteEntries = `-- name: FindVoteEntries :many
SELECT
WG_Surveys.Id AS SurveyId,
WG_Surveys.ChannelID AS SurveyChannel,
WG_Surveys.AnnouncementMessageID,
WG_Surveys.ItemName,
WG_Surveys.OpenedAt,
WG_Surveys.Deadline,
WG_Surveys.Status AS SurveyStatus,
WG_VoteEntries.UserId,
WG_VoteEntries.StatId,
WG_VoteEntries.Value
FROM WG_VoteEntries
INNER JOIN WG_Votes ON WG_Votes.UserId = WG_VoteEntries.UserId AND WG_Votes.SurveyId = WG_VoteEntries.SurveyId
INNER JOIN WG_Surveys ON WG_Surveys.Id = WG_Votes.SurveyId
WHERE (? = 0 OR WG_Votes.Status = ?) 
AND (? = "" OR WG_Votes.SurveyId LIKE ?)
AND (? = "" OR WG_Votes.UserId LIKE ?)
AND (? = "" OR WG_Votes.Token LIKE ?)
LIMIT ? OFFSET ?
`

type FindVoteEntriesParams struct {
	Status    int8        `json:"status"`
	Surveyid  interface{} `json:"surveyid"`
	Surveyopt string      `json:"surveyopt"`
	Userid    interface{} `json:"userid"`
	Idopt     string      `json:"idopt"`
	Token     interface{} `json:"token"`
	Tokenopt  string      `json:"tokenopt"`
	Limit     int32       `json:"limit"`
	Offset    int32       `json:"offset"`
}

type FindVoteEntriesRow struct {
	Surveyid              string    `json:"surveyid"`
	Surveychannel         string    `json:"surveychannel"`
	Announcementmessageid string    `json:"announcementmessageid"`
	Itemname              string    `json:"itemname"`
	Openedat              time.Time `json:"openedat"`
	Deadline              time.Time `json:"deadline"`
	Surveystatus          int8      `json:"surveystatus"`
	Userid                string    `json:"userid"`
	Statid                string    `json:"statid"`
	Value                 float64   `json:"value"`
}

func (q *Queries) FindVoteEntries(ctx context.Context, arg FindVoteEntriesParams) ([]FindVoteEntriesRow, error) {
	rows, err := q.db.QueryContext(ctx, findVoteEntries,
		arg.Status,
		arg.Status,
		arg.Surveyid,
		arg.Surveyopt,
		arg.Userid,
		arg.Idopt,
		arg.Token,
		arg.Tokenopt,
		arg.Limit,
		arg.Offset,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []FindVoteEntriesRow
	for rows.Next() {
		var i FindVoteEntriesRow
		if err := rows.Scan(
			&i.Surveyid,
			&i.Surveychannel,
			&i.Announcementmessageid,
			&i.Itemname,
			&i.Openedat,
			&i.Deadline,
			&i.Surveystatus,
			&i.Userid,
			&i.Statid,
			&i.Value,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const sumStatEntries = `-- name: SumStatEntries :one
SELECT CAST(SUM(value) AS DECIMAL(10,3)) FROM WG_VoteEntries
INNER JOIN WG_Votes ON WG_Votes.SurveyId = WG_VoteEntries.SurveyId AND WG_Votes.UserId = WG_VoteEntries.UserId
WHERE WG_Votes.SurveyId = ? AND WG_VoteEntries.StatId = ? AND WG_Votes.Status = ?
`

type SumStatEntriesParams struct {
	Surveyid string `json:"surveyid"`
	Statid   string `json:"statid"`
	Status   int8   `json:"status"`
}

func (q *Queries) SumStatEntries(ctx context.Context, arg SumStatEntriesParams) (float64, error) {
	row := q.db.QueryRowContext(ctx, sumStatEntries, arg.Surveyid, arg.Statid, arg.Status)
	var column_1 float64
	err := row.Scan(&column_1)
	return column_1, err
}

const sumTotalVotes = `-- name: SumTotalVotes :one
SELECT COUNT(UserId) FROM WG_Votes WHERE SurveyId = ? AND Status != 0
`

func (q *Queries) SumTotalVotes(ctx context.Context, surveyid string) (int64, error) {
	row := q.db.QueryRowContext(ctx, sumTotalVotes, surveyid)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const updateVote = `-- name: UpdateVote :exec
UPDATE WG_Votes SET MessageId = ?, Status = ? WHERE SurveyId = ? AND UserId = ?
`

type UpdateVoteParams struct {
	Messageid string `json:"messageid"`
	Status    int8   `json:"status"`
	Surveyid  string `json:"surveyid"`
	Userid    string `json:"userid"`
}

func (q *Queries) UpdateVote(ctx context.Context, arg UpdateVoteParams) error {
	_, err := q.db.ExecContext(ctx, updateVote,
		arg.Messageid,
		arg.Status,
		arg.Surveyid,
		arg.Userid,
	)
	return err
}
